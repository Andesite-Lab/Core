import { SingletonManager } from '@basalt-lab/basalt-helper/util';
import type { Static, TObject, TSchema } from '@sinclair/typebox';
import { Elysia, t, type Context, type DefinitionBase, type EphemeralType, type MetadataBase, type RouteBase, type RouteSchema, type SingletonBase } from 'elysia';

import type { MSSQL } from '#/core/database/mssql';
import { CoreError } from '#/error/coreError';
import { elysiaKeyError } from '#/error/key/elysiaKeyError';
import type { SelectedFields } from '#/root/source/types';
import type { AdvancedSearch } from '#/types/data/advancedSearch';
import { advancedSearchPlugin, createBaseSearchSchema } from './advancedSearch';
import { dynamicDatabaseSelectorPlugin, type DynamicDatabaseSelectorPluginOptions } from './dynamicDatabaseSelector';

/**
 * Defines the possible CRUD route types that can be enabled or disabled.
 *
 * Each value represents a different CRUD operation that can be automatically
 * generated by the plugin.
 */
type CRUDRoutes = 'insert' | 'find' | 'findOne' | 'update' | 'updateOne' | 'delete' | 'deleteOne' | 'count';

/**
 * Configuration options for the CRUD plugin.
 *
 * This interface provides all necessary parameters to set up automatic CRUD endpoints
 * for a specific database table, including model schema definition, database connection,
 * route inclusion/exclusion, and access control permissions.
 *
 * ### Key Configuration Areas:
 * - Entity naming and API path configuration
 * - Database connection settings
 * - Schema definition for validation and type safety
 * - Route inclusion/exclusion for customizing available operations
 * - Permissions-based access control integration
 *
 * @template TInferedObject - The TypeBox schema type for the entity being managed
 * @template KEnumPermission - The type of the permission enum used for access control
 *
 * @example
 * ```typescript
 * const userSchema = t.Object({
 *   id: t.Number(),
 *   name: t.String(),
 *   email: t.String({ format: 'email' }),
 *   role: t.String(),
 *   createdAt: t.String({ format: 'date-time' })
 * });
 *
 * const crudOptions: CrudOptions<typeof userSchema> = {
 *   tableName: 'users',
 *   prefix: '/api/users',
 *   database: 'main_db',
 *   baseSchema: userSchema,
 *   insertPropertiesSchemaRequired: ['name', 'email'],
 *   includedRoutes: ['find', 'findOne', 'insert', 'update'],
 *   permissionConfig: {
 *     permissionsPlugin: permissionsPlugin,
 *     operationsPermissions: {
 *       find: ['users:read'],
 *       findOne: ['users:read'],
 *       insert: ['users:create'],
 *       update: ['users:update']
 *     }
 *   }
 * };
 * ```
 */
interface CrudOptions<
    TInferedObject extends TObject,
    KEnumPermission extends string
> {
    /**
     * Optional API path prefix for all generated routes.
     *
     * When specified, all routes will be prefixed with this path.
     * For example, if prefix is '/api/users', the find route will be '/api/users/find'.
     *
     * @defaultValue ''
     */
    prefix?: string;

    /**
     * The name of the table this CRUD interface will manage.
     *
     * This should match the database table name and will be used to identify
     * the repository and models in the generated API.
     */
    tableName: string;

    /**
     * Database configuration for the CRUD operations.
     *
     * This can either be a string (database name) for static connections or a
     * DynamicDatabaseSelectorPluginOptions object for dynamic database selection.
     *
     * @example
     * ```typescript
     * // Static database connection
     * database: 'my_database'
     *
     * // Dynamic database selection
     * database: {
     *   baseDatabaseConfig: {
     *     host: 'localhost',
     *     port: 1433,
     *     user: 'sa',
     *     password: 'Password123'
     *   },
     *   headerKey: 'x-tenant-db'
     * }
     * ```
     */
    database: string | DynamicDatabaseSelectorPluginOptions;

    /**
     * The TypeBox schema defining the structure of the entity.
     *
     * This schema is used for:
     * - Validating input data
     * - Generating TypeScript types
     * - Creating model definitions for Elysia
     * - Informing the structure of database operations
     */
    baseSchema: TInferedObject;

    /**
     * Array of property names from the schema that should be required in insert operations.
     *
     * When specified, these properties will be required in the body of insert requests,
     * while other properties will remain optional.
     *
     * @example
     * ```typescript
     * // Makes name and email required for insertion, while other fields remain optional
     * insertPropertiesSchemaRequired: ['name', 'email']
     * ```
     */
    insertPropertiesSchemaRequired?: (keyof Static<TInferedObject>)[];

    /**
     * Array of route types to include in the generated API.
     *
     * When specified, only these routes will be generated. This allows for precise
     * control over which operations are available through the API.
     *
     * @example
     * ```typescript
     * // Only generate read-only routes
     * includedRoutes: ['find', 'findOne', 'count']
     * ```
     */
    includedRoutes?: CRUDRoutes[];

    /**
     * Array of route types to exclude from the generated API.
     *
     * When specified, these routes will be omitted from generation, even if they
     * would normally be included by default.
     *
     * @example
     * ```typescript
     * // Generate all routes except delete operations
     * excludedRoutes?: ['delete', 'deleteOne']
     * ```
     */
    excludedRoutes?: CRUDRoutes[];

    /**
     * Configuration for permissions integration with CRUD operations.
     *
     * This object contains the permissions plugin and mapping of operations to required permissions,
     * enabling role-based access control for your CRUD API.
     */
    permissionConfig: {
        /**
         * The permissions plugin instance to integrate with CRUD operations.
         *
         * This plugin is used to enforce authorization rules for each CRUD operation,
         * ensuring only users with appropriate permissions can access specific routes.
         */
        permissionsPlugin: Elysia<
            '',
            SingletonBase,
            DefinitionBase,
            MetadataBase & {
                schema: RouteSchema;
                macro: Partial<{
                    readonly needsOnePermission: KEnumPermission[];
                    readonly needsMultiplePermissions: KEnumPermission[];
                }>;
                macroFn: {
                    readonly needsOnePermission: (permissions: KEnumPermission[]) => {
                        beforeHandle: (ctx: Context) => Promise<void>;
                    };
                    readonly needsMultiplePermissions: (permissions: KEnumPermission[]) => {
                        beforeHandle: (ctx: Context) => Promise<void>
                    };
                }
            },
            RouteBase,
            EphemeralType,
            EphemeralType
        >,

        /**
         * Mapping of CRUD operations to required permissions.
         *
         * This object defines which permissions are needed for each type of CRUD operation,
         * allowing for fine-grained access control at the operation level.
         *
         * @example
         * ```typescript
         * operationsPermissions: {
         *   find: ['users:read'],
         *   findOne: ['users:read'],
         *   insert: ['users:create'],
         *   update: ['users:edit', 'users:admin'],
         *   delete: ['users:admin']
         * }
         * ```
         */
        operationsPermissions: Partial<Record<CRUDRoutes, KEnumPermission[]>>;
    }
}

/**
 * Creates a response schema for the CRUD plugin operations.
 *
 * This function builds a TypeBox schema that represents the standard response format
 * for CRUD operations, handling null and undefined values appropriately.
 *
 * The response schema follows a standard format with a message and content array:
 * ```
 * {
 *   message: string,
 *   content: Array<Partial<T>>
 * }
 * ```
 *
 * @template TInferedObject - The inferred schema type for the base object
 * @param schema - The schema to build the response schema for
 *
 * @returns TypeBox schema for the standard CRUD operation response
 *
 * @example
 * ```typescript
 * const userSchema = t.Object({
 *   id: t.Number(),
 *   name: t.String(),
 *   email: t.String()
 * });
 *
 * const responseSchema = createResponse200Schema(userSchema);
 * // Creates a schema for:
 * // {
 * //   message: string,
 * //   content: Array<{
 * //     id?: number | null,
 * //     name?: string | null,
 * //     email?: string | null
 * //   }>
 * // }
 * ```
 */
export const createResponse200Schema = <TInferedObject extends TObject>(schema: TInferedObject) => {
    const { properties } = schema;

    const contentSchema = {} as Record<string, TSchema>;

    for (const key in properties)
        contentSchema[key] = t.Union([
            properties[key],
            t.Undefined(),
            t.Null(),
            t.Literal('')
        ]);

    return t.Object({
        message: t.String(),
        content: t.Array(t.Partial(t.Object(contentSchema)))
    });
};

/**
 * Creates an insert body schema for CRUD operations.
 *
 * This function builds a body schema for insert operations, applying required
 * constraints to specified properties while leaving others optional.
 *
 * @template TInferedObject - The inferred schema type for the base object
 * @param schema - The schema to build the insert body schema from
 * @param requiredPropertiesSchema - Optional array of property keys that should be required
 *
 * @returns TypeBox schema for the insert operation request body
 *
 * @example
 * ```typescript
 * const userSchema = t.Object({
 *   id: t.Number(),
 *   name: t.String(),
 *   email: t.String(),
 *   role: t.String()
 * });
 *
 * // Create a schema where name and email are required, but id and role are optional
 * const insertSchema = createInsertBodySchema(userSchema, ['name', 'email']);
 * ```
 */
export const createInsertBodySchema = <TInferedObject extends TObject>(schema: TInferedObject, requiredPropertiesSchema?: (keyof Static<TInferedObject>)[]) => {
    const { properties } = schema;

    const contentSchema = {} as Record<string, TSchema>;

    for (const key in properties)
        contentSchema[key] = requiredPropertiesSchema?.includes(key)
            ? properties[key]
            : t.Optional(properties[key]);

    return t.Object(contentSchema);
};

/**
 * Adds model definitions to the Elysia application based on enabled routes.
 *
 * This internal function sets up all the necessary validation schemas for request
 * bodies, URL parameters, and responses for each enabled CRUD route.
 *
 * @template TInferedObject - The inferred schema type for the base object
 * @param enabledRoutes - Array of routes that are enabled for this CRUD interface
 * @param options - The main CRUD options containing schema information
 *
 * @returns An Elysia plugin containing all the model definitions
 */
const _addModels = <TInferedObject extends TObject, KEnumPermission extends string>(enabledRoutes: CRUDRoutes[], options: CrudOptions<TInferedObject, KEnumPermission>) => {
    const { baseSchema, tableName, insertPropertiesSchemaRequired } = options;

    // Initialize plugin with common response schema
    const plugin = new Elysia().model({
        [`crud${tableName}Response200`]: createResponse200Schema(baseSchema)
    });

    // Map of route types to their corresponding model definitions
    const routeModelMap: Partial<Record<CRUDRoutes, () => void>> = {
        insert: () => plugin.model({
            [`crud${tableName}InsertBody`]: createInsertBodySchema(baseSchema, insertPropertiesSchemaRequired)
        }),
        update: () => plugin.model({
            [`crud${tableName}UpdateBody`]: t.Partial(baseSchema)
        }),
        count: () => plugin.model({
            [`crud${tableName}CountResponse200`]: t.Object({
                message: t.String(),
                content: t.Number()
            })
        })
    };

    // Add route-specific models
    enabledRoutes.forEach((route) => {
        if (route in routeModelMap)
            routeModelMap[route]?.();
    });

    // Routes that require ID parameter
    const routesWithIdParam = ['findOne', 'deleteOne', 'updateOne'] as const;

    // Add ID parameter model if any route requires it
    if (routesWithIdParam.some((route) => enabledRoutes.includes(route)))
        plugin.model({
            [`crud${tableName}IdParam`]: t.Object({
                id: t.Union([t.String(), t.Number()])
            })
        });
    return plugin;
};

/**
 * Determines which routes should be enabled based on included and excluded routes.
 *
 * This function calculates the final set of enabled routes by starting with either
 * the specified included routes or all available routes, then removing any routes
 * that are in the excluded list.
 *
 * @param includedRoutes - List of routes to include
 * @param excludedRoutes - List of routes to exclude
 *
 * @returns Array of enabled routes
 */
const _getEnabledRoutes = (includedRoutes: CRUDRoutes[] = [], excludedRoutes: CRUDRoutes[] = []): CRUDRoutes[] => {
    // Define all available routes as a constant to improve maintainability
    const allRoutes: CRUDRoutes[] = ['insert', 'find', 'findOne', 'update', 'updateOne', 'delete', 'deleteOne', 'count'];

    // Start with either the included routes or all routes
    const enabledRoutes = includedRoutes.length > 0
        ? includedRoutes
        : allRoutes;

    // Filter out excluded routes
    return excludedRoutes.length > 0
        ? enabledRoutes.filter((route) => !excludedRoutes.includes(route))
        : enabledRoutes;
};

/**
 * Injects the appropriate database configuration into the context.
 *
 * This function sets up either a static database connection or dynamic database
 * selection based on the provided configuration.
 *
 * @param database - Either a string (static database name) or configuration for dynamic database selection
 * @returns An Elysia plugin with the database context
 */
const _injectDynamicDbInContext = (database: string | DynamicDatabaseSelectorPluginOptions) => {
    const plugin = new Elysia();
    const isDynamicDatabase = typeof database !== 'string';

    if (!isDynamicDatabase)
        // Static database configuration
        plugin.resolve(() => ({
            dynamicDB: SingletonManager.get<MSSQL>(`database:${database}`)
        }));
    else
        // Dynamic database configuration
        plugin.use(dynamicDatabaseSelectorPlugin({
            baseDatabaseConfig: database.baseDatabaseConfig,
            headerKey: database.headerKey || 'database-using'
        }));
    return plugin.as('scoped');
};

/**
 * Collection of handler functions for different CRUD operations.
 *
 * These functions implement the business logic for each CRUD operation,
 * interacting with the appropriate repository methods and formatting
 * the response data.
 */
const handlerDefinition = {
    /**
     * Handles inserting a new record.
     * Gets the database and repository, then inserts the data and returns a success message.
     */
    insertHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);

        const { body } = ctx as { body: Partial<unknown> };
        const data = await repo.insert(body);
        return {
            message: `Inserted record for ${tableName}`,
            content: data
        };
    },

    /**
     * Handles finding multiple records with filtering and pagination.
     * Gets the database and repository, then finds matching records and returns them.
     */
    findHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);

        const data = await repo.find({
            advancedSearch: ctx.advancedSearch as AdvancedSearch<unknown>[],
            selectedFields: ctx.selectedFields as SelectedFields<unknown>,
            limit: (ctx.pagination as { limit: number; offset: number }).limit,
            offset: (ctx.pagination as { limit: number; offset: number }).offset
        });
        return {
            message: `Found ${data.length} records for ${tableName}`,
            content: data
        };
    },

    /**
     * Handles finding a single record by ID.
     * Gets the database, repository and table, then finds the record by primary key.
     */
    findOneHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as unknown as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);
        const table = db.getTable(tableName);
        const primary = table.primaryKey;

        const { id } = ctx.params as { id: string | number };

        const data = await repo.findOne({
            advancedSearch: {
                [primary[0]]: id
            } as AdvancedSearch<unknown>
        });
        return {
            message: `Found record for ${tableName}`,
            content: data
        };
    },

    /**
     * Handles counting records that match specific criteria.
     * Gets the database and repository, then counts matching records.
     */
    countHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);
        const count = await repo.count({
            advancedSearch: ctx.advancedSearch as AdvancedSearch<unknown>[]
        });
        return {
            message: `${count} records found for ${tableName}`,
            content: count
        };
    },

    /**
     * Handles updating multiple records that match specific criteria.
     * Gets the database and repository, validates search criteria, then updates matching records.
     */
    updateHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);

        if (!ctx.advancedSearch || (ctx.advancedSearch as AdvancedSearch<unknown>[]).length === 0 || !(ctx.advancedSearch as AdvancedSearch<unknown>[])[0])
            throw new CoreError({
                key: elysiaKeyError.needAdvancedSearch,
                message: 'You need to provide advanced search to update records. It\'s dangerous to update all records.',
                httpStatusCode: 400
            });

        const data = await repo.update((ctx.body as Record<string, unknown>), {
            advancedSearch: ctx.advancedSearch as AdvancedSearch<unknown>[],
            selectedFields: ctx.selectedField as SelectedFields<unknown>
        });

        return {
            message: `Updated ${data.length} records for ${tableName}`,
            content: data
        };
    },

    /**
     * Handles updating a single record by ID.
     * Gets the database, repository and table, then updates the record by primary key.
     */
    updateOneHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);
        const table = db.getTable(tableName);
        const primary = table.primaryKey;

        const { id } = ctx.params as { id: string | number };

        const data = await repo.update(ctx.body as Record<string, unknown>, {
            advancedSearch: {
                [primary[0]]: id
            } as AdvancedSearch<unknown>
        });

        return {
            message: `Updated record for ${tableName}`,
            content: data
        };
    },

    /**
     * Handles deleting multiple records that match specific criteria.
     * Gets the database and repository, validates search criteria, then deletes matching records.
     */
    deleteHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);

        if (!ctx.advancedSearch || (ctx.advancedSearch as AdvancedSearch<unknown>[]).length === 0 || !(ctx.advancedSearch as AdvancedSearch<unknown>[])[0])
            throw new CoreError({
                key: elysiaKeyError.needAdvancedSearch,
                message: 'You need to provide advanced search to delete records. It\'s dangerous to delete all records.',
                httpStatusCode: 400
            });

        const data = await repo.delete({
            advancedSearch: ctx.advancedSearch as AdvancedSearch<unknown>[],
            selectedFields: ctx.selectedFields as SelectedFields<unknown>
        });

        return {
            message: `Deleted ${data.length} records for ${tableName}`,
            content: data
        };
    },

    /**
     * Handles deleting a single record by ID.
     * Gets the database, repository and table, then deletes the record by primary key.
     */
    deleteOneHandler: async (ctx: Record<string, unknown>, tableName: string) => {
        const db = (ctx as { dynamicDB: MSSQL }).dynamicDB;
        const repo = db.getRepository(tableName);
        const table = db.getTable(tableName);
        const primary = table.primaryKey;

        const { id } = ctx.params as { id: string | number };

        const data = await repo.delete({
            advancedSearch: {
                [primary[0]]: id
            } as AdvancedSearch<unknown>
        });

        return {
            message: `Deleted record for ${tableName}`,
            content: data
        };
    }
} as const;

/**
 * Adds the appropriate CRUD routes to an Elysia application.
 *
 * This function configures the HTTP methods, paths, handlers, and validation
 * for each enabled CRUD operation.
 *
 * @param enabledRoutes - Array of routes that should be enabled
 * @param tableName - The name of the table being managed
 * @param baseSchema - The TypeBox schema for the data model
 * @param isDynamicDatabase - Whether to use dynamic database selection
 * @returns A function that adds the routes to an Elysia application
 */
const _addRoutes = <TInferedObject extends TObject>
(
    enabledRoutes: CRUDRoutes[],
    tableName: string,
    baseSchema: TInferedObject,
    isDynamicDatabase: boolean
) => (app: Elysia) => {
    const routesMethods: Partial<Record<CRUDRoutes, 'post' | 'get' | 'patch' | 'delete'>> = {
        insert: 'post',
        find: 'get',
        findOne: 'get',
        count: 'get',
        update: 'patch',
        updateOne: 'patch',
        delete: 'delete',
        deleteOne: 'delete'
    };

    const routesPath: Partial<Record<CRUDRoutes, string>> = {
        insert: '/',
        find: '/',
        findOne: '/:id',
        count: '/count',
        update: '/',
        updateOne: '/:id',
        delete: '/',
        deleteOne: '/:id'
    };

    const hasAdvancedSearch = enabledRoutes.includes('find') || enabledRoutes.includes('count') || enabledRoutes.includes('update') || enabledRoutes.includes('delete');

    if (hasAdvancedSearch)
        app.use(advancedSearchPlugin(tableName, baseSchema));


    for (const route of enabledRoutes) {
        const method = routesMethods[route];
        const path = routesPath[route];

        if (method && path) {
            const handler = handlerDefinition[`${route}Handler`];

            const definition = {
                ...(route === 'findOne' || route === 'deleteOne' || route === 'updateOne'
                    ? { params: `crud${tableName}IdParam` as unknown as TObject }
                    : {}
                ),

                ...(route === 'count' || route === 'update' || route === 'delete'
                    ? { query: createBaseSearchSchema(baseSchema) } // can't use ref (https://discord.com/channels/1044804142461362206/1323026325531000842)
                    : route === 'find'
                        ? { query: createBaseSearchSchema(baseSchema) } // can't use ref (https://discord.com/channels/1044804142461362206/1323026325531000842)
                        : {}
                ),

                ...(route === 'insert' || route === 'update' || route === 'updateOne'
                    ? { body: `crud${tableName}${route === 'insert' ? 'Insert' : 'Update'}Body` as unknown as TObject }
                    : {}
                ),

                response: `crud${tableName}${route === 'count' ? 'Count' : ''}Response200` as unknown as TObject,
                hasAdvancedSearch: true as unknown as never,
                hasDynamicDatabaseSelector: isDynamicDatabase as unknown as never
            };

            app[method](path, (ctx) => handler(ctx, tableName), definition);
        }
    }
    return app;
};

/**
 * The `crudPlugin` generates a complete set of RESTful CRUD endpoints for a database table.
 *
 * This plugin automates the creation of standard CRUD operations (Create, Read, Update, Delete)
 * for a specific database entity. It integrates with database access, validation, permissions,
 * and dynamic database selection to provide a fully-functional API with minimal configuration.
 *
 * ### Key Features:
 * - **Automatic Route Generation**: Creates standardized routes for all CRUD operations
 * - **Schema-Based Validation**: Uses TypeBox schemas for request/response validation
 * - **Permissions Integration**: Fine-grained access control for each operation
 * - **Dynamic or Static Database Selection**: Works with fixed or per-request database connections
 * - **Flexible Route Configuration**: Include or exclude specific operations as needed
 * - **Consistent Response Format**: Standardized response structure across all endpoints
 *
 * ### Endpoint Overview:
 * The plugin can generate the following endpoints (depending on configuration):
 * - `POST /insert`: Create new records
 * - `GET /find`: Retrieve multiple records with filtering, pagination, and field selection
 * - `GET /find/:id`: Retrieve a single record by ID
 * - `PATCH /update`: Update multiple records based on filter criteria
 * - `PATCH /update/:id`: Update a single record by ID
 * - `DELETE /delete`: Delete multiple records based on filter criteria
 * - `DELETE /delete/:id`: Delete a single record by ID
 * - `GET /count`: Count records matching filter criteria
 *
 * @template TInferedObject - The TypeBox schema type for the entity being managed
 * @param options - Configuration options for the CRUD plugin
 *
 * @returns An Elysia plugin with configured CRUD routes
 *
 * @example
 * ```typescript
 * import { Elysia, t } from 'elysia';
 * import { crudPlugin } from '#/core/elysia/plugin/crud';
 * import { permissionsPlugin } from './permissions';
 *
 * // Define the schema for your entity
 * const userSchema = t.Object({
 *   id: t.Number(),
 *   username: t.String(),
 *   email: t.String({ format: 'email' }),
 *   isActive: t.Boolean(),
 *   createdAt: t.String({ format: 'date-time' })
 * });
 *
 * // Create the CRUD API
 * const app = new Elysia()
 *   .use(permissionsPlugin)
 *   .use(crudPlugin({
 *     tableName: 'users',
 *     prefix: '/api/users',
 *     database: 'mainDb',
 *     baseSchema: userSchema,
 *     insertPropertiesSchemaRequired: ['username', 'email'],
 *     excludedRoutes: ['delete'], // Disable bulk delete for safety
 *     permissionConfig: {
 *       permissionsPlugin,
 *       operationsPermissions: {
 *         find: ['users:read'],
 *         findOne: ['users:read'],
 *         insert: ['users:create'],
 *         update: ['users:update'],
 *         updateOne: ['users:update'],
 *         deleteOne: ['users:admin']
 *       }
 *     }
 *   }))
 *   .listen(3000);
 * ```
 */
export const crudPlugin = <
    TInferedObject extends TObject,
    KEnumPermission extends string
>(options: CrudOptions<TInferedObject, KEnumPermission>) => {
    const enabledRoutes = _getEnabledRoutes(options.includedRoutes, options.excludedRoutes);
    const app = new Elysia({
        name: `crudPlugin[${options.tableName}]`,
        tags: [options.tableName]
    })
        .use(_addModels(enabledRoutes, options))
        .use(options.permissionConfig.permissionsPlugin);
    app
        .use(_injectDynamicDbInContext(options.database))
        .use(_addRoutes(
            enabledRoutes,
            options.tableName,
            options.baseSchema,
            !(typeof options.database === 'string')
        ));
    return app;
};