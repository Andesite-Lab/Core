import { Elysia } from 'elysia';
import {
    SignJWT,
    jwtVerify,
    type JWSHeaderParameters,
    type JWTPayload
} from 'jose';

import { CoreError } from '#/root/source/error/coreError';
import { ELYSIA_KEY_ERROR } from '#/root/source/error/key/elysiaKeyError';

/**
 * Configuration options for the JWT plugin.
 *
 * This interface provides all necessary configuration parameters to set up
 * JWT functionality in Elysia applications. It includes essential settings
 * such as the secret key for signing tokens, as well as optional configurations
 * for token expiration, headers, and default payload values.
 *
 * ### Key Configuration Areas:
 * - Plugin naming for accessing JWT functionality
 * - Secret key for token signing and verification
 * - Token expiration settings
 * - Custom JWT headers
 * - Default payload values
 *
 * @template TPluginName - The name to be used for accessing the JWT functionality in the Elysia context
 *
 * @example
 * ```typescript
 * const options: JWTOption = {
 *   name: 'auth',
 *   secret: process.env.JWT_SECRET || 'your-secret-key',
 *   exp: '1d',
 *   header: {
 *     alg: 'HS256',
 *     typ: 'JWT'
 *   },
 *   payload: {
 *     iss: 'my-api',
 *     aud: 'my-client'
 *   }
 * };
 * ```
 */
export interface JWTOption<TPluginName extends string | undefined = 'jwt'> {
    /**
     * JWT name to add in context with decorate.
     * This will be the property name used to access JWT functionality.
     *
     * This allows you to customize how you access the JWT functionality in your
     * route handlers. For example, if set to 'auth', you would use `auth.sign()`
     * instead of the default `jwt.sign()`.
     *
     * @defaultValue 'jwt'
     *
     * @example
     * ```typescript
     * // With default name
     * app.post('/login', ({ jwt, body }) => {
     *   const token = jwt.sign({ userId: body.id });
     *   return { token };
     * });
     *
     * // With custom name 'auth'
     * app.post('/login', ({ auth, body }) => {
     *   const token = auth.sign({ userId: body.id });
     *   return { token };
     * });
     * ```
     */
    name?: TPluginName;

    /**
     * Secret key used to sign and verify JWTs.
     *
     * This is a required parameter that defines the secret used for both
     * signing new tokens and verifying existing ones. The security of your
     * tokens depends on keeping this value private and secure.
     *
     * @example
     * ```typescript
     * // Using a string secret
     * secret: 'your-very-secret-key'
     *
     * // Using an environment variable (recommended for production)
     * secret: process.env.JWT_SECRET
     * ```
     */
    secret: string;

    /**
     * JWT expiration setting. Applies as the default expiration for tokens.
     *
     * Controls how long tokens are valid before they expire. This setting provides
     * a good balance between security (limiting the window of opportunity for token misuse)
     * and user experience (not requiring frequent re-authentication).
     *
     * @defaultValue '15m' (15 minutes)
     *
     * @example
     * ```typescript
     * // Set tokens to expire after 1 hour
     * exp: '1h'
     *
     * // Set tokens to expire at a specific date
     * exp: new Date('2023-12-31')
     *
     * // Set tokens to expire after 3600 seconds (1 hour)
     * exp: 3600
     * ```
     */
    exp?: number | string | Date;

    /**
     * Default JWT header parameters.
     *
     * These parameters are included in the protected header portion of the JWT.
     * The 'alg' property defaults to 'HS256' if not specified, which is the
     * HMAC SHA-256 algorithm commonly used for JWT signing.
     *
     * @example
     * ```typescript
     * header: {
     *   alg: 'HS256',
     *   typ: 'JWT',
     *   kid: 'key-id-12345'
     * }
     * ```
     */
    header?: JWSHeaderParameters;

    /**
     * Default payload values to include in every JWT.
     *
     * These values are merged with any additional payload provided during signing,
     * allowing you to set standard claims that should be included in all tokens
     * generated by your application.
     *
     * @example
     * ```typescript
     * payload: {
     *   iss: 'my-api',           // Issuer
     *   aud: 'my-frontend',      // Audience
     *   roles: ['user'],         // Default roles
     *   version: '1.0'           // API version
     * }
     * ```
     */
    payload?: JWTPayload;
}

/**
 * The `jwtPlugin` provides JSON Web Token (JWT) authentication capabilities for Elysia applications.
 *
 * This plugin simplifies the process of generating and verifying JWTs with strong typing support.
 * It leverages the jose library for secure token handling and integrates seamlessly with Elysia's
 * context system, making it easy to add authentication to your API endpoints.
 *
 * ### Key Features:
 * - **Simple JWT Generation**: Create tokens with configurable payloads and expiration times
 * - **Secure Verification**: Easily verify and decode tokens with built-in signature validation
 * - **Default Claims**: Automatically include standard JWT claims like issuer and audience
 * - **Flexible Configuration**: Customize token behavior with sensible defaults
 * - **TypeScript Integration**: Full type inference for JWT payloads and plugin options
 *
 * The plugin adds two primary methods to your Elysia context:
 * - `sign()`: Generate and sign new JWTs
 * - `verify()`: Validate and decode existing JWTs
 *
 * @template Name - The name to use for JWT functionality in the context (default: 'jwt')
 * @param options - Configuration options for the JWT plugin
 *
 * @returns An Elysia plugin that adds JWT functionality to the application context
 *
 * @example
 * ```typescript
 * import { Elysia } from 'elysia';
 * import { jwtPlugin } from '#/core/elysia/plugin/jwt';
 *
 * const app = new Elysia()
 *   // Add JWT plugin with configuration
 *   .use(jwtPlugin({
 *     name: 'auth',
 *     secret: process.env.JWT_SECRET || 'your-secret-key',
 *     exp: '1d',
 *     payload: {
 *       iss: 'my-api',
 *       aud: 'my-client'
 *     }
 *   }))
 *
 *   // Login route that generates a token
 *   .post('/login', async ({ auth, body }) => {
 *     // Authenticate user (example)
 *     if (body.username === 'admin' && body.password === 'password') {
 *       // Generate a token with user-specific data
 *       const token = await auth.sign({
 *         userId: 123,
 *         username: body.username,
 *         role: 'admin'
 *       });
 *
 *       return { success: true, token };
 *     }
 *
 *     return { success: false, message: 'Invalid credentials' };
 *   })
 *
 *   // Protected route that requires authentication
 *   .get('/protected', async ({ auth, request, set }) => {
 *     // Extract token from Authorization header
 *     const authHeader = request.headers.get('authorization');
 *     const token = authHeader?.split(' ')[1];
 *
 *     // Verify the token
 *     const payload = await auth.verify(token);
 *
 *     if (!payload) {
 *       set.status = 401;
 *       return { success: false, message: 'Unauthorized' };
 *     }
 *
 *     // Access payload data (fully typed)
 *     return {
 *       success: true,
 *       message: `Hello ${payload.username}!`,
 *       userId: payload.userId,
 *       role: payload.role
 *     };
 *   })
 *
 *   .listen(3000);
 * ```
 */
export const jwtPlugin = <const Name extends string = 'jwt'>(options: JWTOption<Name>) => {
    // Check if the secret is provided
    if (!options.secret)
        throw new CoreError({
            key: ELYSIA_KEY_ERROR.JWT_SECRET_NOT_FOUND,
            message: 'Secret key is required for JWT signing and verification.'
        });

    // Encode string secret to Uint8Array
    const key = new TextEncoder().encode(options.secret);

    // Create name of the decorated key
    const name = options.name ?? 'jwt' as Name;

    return new Elysia({
        name: 'jwtPlugin',
        seed: options
    })
        .decorate(name, {
            /**
             * Signs a payload and creates a JSON Web Token (JWT).
             *
             * This method creates a signed JWT containing the provided payload data plus
             * any default values configured in the plugin options. It automatically handles
             * setting standard claims like issuer, audience, and JWT ID.
             *
             * @param additionalPayload - The custom data to include in the token
             * @param exp - Optional expiration time override (defaults to plugin configuration)
             *
             * @returns A promise that resolves to the signed JWT string
             *
             * @throws ({@link CoreError}) If there's an error during the signing process. ({})
             *
             * @example
             * ```typescript
             * // Basic usage
             * const token = await jwt.sign({ userId: 123 });
             *
             * // With custom expiration
             * const shortLivedToken = await jwt.sign(
             *   { permission: 'file-download', fileId: 'abc123' },
             *   '5m'
             * );
             *
             * // With multiple custom claims
             * const adminToken = await jwt.sign({
             *   userId: 456,
             *   username: 'admin',
             *   roles: ['admin', 'editor'],
             *   permissions: {
             *     users: 'manage',
             *     content: 'publish'
             *   }
             * });
             * ```
             */
            sign(
                additionalPayload?: JWTPayload,
                exp: number | string | Date = options.exp ?? '15m'
            ) {
                const payload: JWTPayload = {
                    iss: 'core',
                    aud: 'core client',
                    jti: Bun.randomUUIDv7(),
                    ...options.payload,
                    ...additionalPayload
                };
                try {
                    return new SignJWT(payload)
                        .setProtectedHeader({
                            alg: 'HS256',
                            b64: true
                        })
                        .setIssuer(payload.iss ?? 'core')
                        .setAudience(payload.aud ?? 'client')
                        .setExpirationTime(exp)
                        .sign(key);
                } catch {
                    throw new CoreError({
                        key: ELYSIA_KEY_ERROR.JWT_SIGN_ERROR,
                        message: 'Error signing JWT.'
                    });
                }
            },

            /**
             * Verifies and decodes a JSON Web Token (JWT).
             *
             * This method validates the token's signature using the plugin's configured
             * secret key and checks that the token hasn't expired. If the token is valid,
             * it returns the decoded payload; otherwise, it returns false.
             *
             * @param jwt - The JWT string to verify and decode
             *
             * @returns A promise that resolves to either the decoded payload or false if verification fails
             *
             * @example
             * ```typescript
             * // Basic verification
             * const payload = await jwt.verify(token);
             * if (payload) {
             *   console.log('Valid token for user:', payload.userId);
             * } else {
             *   console.log('Invalid or expired token');
             * }
             *
             * // In a route handler
             * app.get('/profile', async ({ jwt, request, set }) => {
             *   const token = request.headers.get('authorization')?.split(' ')[1];
             *   const payload = await jwt.verify(token);
             *
             *   if (!payload) {
             *     set.status = 401;
             *     return { error: 'Unauthorized' };
             *   }
             *
             *   // Token is valid, use the payload data
             *   return fetchUserProfile(payload.userId);
             * });
             * ```
             */
            async verify(jwt?: string): Promise<JWTPayload | false> {
                if (!jwt)
                    return false;
                try {
                    const data = (await jwtVerify(jwt, key)).payload;
                    return data;
                } catch {
                    return false;
                }
            }
        })
        .as('plugin');
};
